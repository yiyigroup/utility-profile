<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Underground Utility Coordination – Profile Tool</title>
  <style>
    :root{
      --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e2e8f0; --accent:#2563eb;
      --sd:#16a34a; --sewer:#a16207; --pipe:#1d4ed8; --card:#f8fafc;
    }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    h1{font-size:22px;margin:0 0 12px}
    .grid{display:grid;grid-template-columns:1.2fr 1fr;gap:16px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .row{display:flex;flex-wrap:wrap;gap:10px}
    .field{display:flex;flex-direction:column;gap:6px;min-width:120px}
    .field label{font-size:12px;color:var(--muted)}
    .field input{appearance:textfield;padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:#fff}
    .btn{padding:10px 12px;border-radius:10px;border:1px solid var(--line);background:#fff;cursor:pointer}
    .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
    .tbl{width:100%;border-collapse:separate;border-spacing:0 8px}
    .tbl th{font-size:12px;color:var(--muted);text-align:left;padding:0 8px}
    .tbl td{background:#fff;border:1px solid var(--line);padding:6px 8px;border-radius:8px}
    .tbl input{width:100%;border:none;outline:none;padding:6px 4px;background:transparent}
    .kpi{font-size:12px;color:var(--muted)}
    .note{font-size:12px;color:var(--muted);margin-top:6px}
    .legend{display:flex;gap:16px;align-items:center;font-size:12px;color:var(--muted)}
    .chip{display:inline-flex;align-items:center;gap:6px}
    .sw{width:20px;height:3px;display:inline-block;border-radius:2px}
    .sw.pipe{background:var(--pipe)}
    .sw.surface{background:#0ea5e9}
    .sw.sd{background:var(--sd)}
    .sw.sewer{background:var(--sewer)}
    .profile-box{position:relative;height:520px}
    #svg{width:100%;height:100%;display:block;background:#fff;border:1px solid var(--line);border-radius:12px}
    .footer{margin-top:10px;display:flex;justify-content:space-between;align-items:center}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Underground Utility Coordination – Profile Tool</h1>
    <div class="grid">
      <!-- Left: Profile & Legend -->
      <div class="card">
        <div class="legend" id="legend">
          <span class="chip"><i class="sw surface"></i>Surface @ <span id="lgSurf">20.00</span> ft</span>
          <span class="chip"><i class="sw pipe"></i>PVC Water Pipe (OD <span id="lgOD">12</span>")</span>
          <span class="chip"><i class="sw sd"></i>Storm Drain</span>
          <span class="chip"><i class="sw sewer"></i>Sewer</span>
        </div>
        <div class="profile-box">
          <svg id="svg" viewBox="0 0 1100 520" preserveAspectRatio="none" aria-label="Underground utility profile"></svg>
        </div>
        <div class="footer">
          <div class="kpi">Stations: <span id="staStart">0+00</span> → <span id="staEnd">50+00</span> (feet)</div>
          <button id="downloadSvg" class="btn">Download SVG</button>
        </div>
      </div>

      <!-- Right: Inputs -->
      <div class="card">
        <div class="row">
          <div class="field">
            <label for="surfaceElev">Surface Elevation (ft)</label>
            <input type="number" step="0.01" id="surfaceElev" value="20" />
          </div>
          <div class="field">
            <label for="coverStart">Pipe Cover @ 0+00 (ft)</label>
            <input type="number" step="0.1" id="coverStart" value="4" />
          </div>
          <div class="field">
            <label for="slopePct">Pipe Slope (%, L→R)</label>
            <input type="number" step="0.01" id="slopePct" value="0.2" />
          </div>
          <div class="field">
            <label for="pipeOD">Pipe OD (in)</label>
            <input type="number" step="0.01" id="pipeOD" value="12" />
          </div>
          <div class="field">
            <label for="projectLen">Project End Station (e.g., 50+00)</label>
            <input type="text" id="projectLen" value="50+00" />
          </div>
        </div>
        <p class="note">Changing any value updates the profile instantly. Clearances are computed between outside surfaces at the crossing station.</p>

        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="addRow" class="btn">Add Utility</button>
          <button id="deleteSelected" class="btn">Delete Selected</button>
          <button id="exportJSON" class="btn">Export JSON</button>
          <input type="file" id="importJSON" accept="application/json" class="btn" title="Import JSON" />
        </div>

        <table class="tbl" style="margin-top:10px">
          <thead>
            <tr>
              <th style="width:44px">Sel</th>
              <th>Utility ID</th>
              <th>Owner</th>
              <th>Type</th>
              <th>Size (in)</th>
              <th>Depth (ft to TOP)</th>
              <th>Station</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // ---------- Helpers: station formatting & parsing ----------
    function parseStation(text){
      if(typeof text === 'number') return text;
      if(!text) return 0;
      const t = (""+text).trim();
      const m = t.match(/^(\d+)\+(\d{2})$/);
      if(m){return parseInt(m[1],10)*100 + parseInt(m[2],10);} // interpret as *100 for CAD-like short feet
      // Fallback: raw feet
      const n = parseFloat(t.replace(/[,\s]/g,''));
      return isFinite(n)? n : 0;
    }
    function fmtStation(ft){
      const f = Math.max(0, Math.round(ft));
      const hundreds = Math.floor(f/100);
      const rem = f - hundreds*100;
      return `${hundreds}+${String(rem).padStart(2,'0')}`;
    }

    // ---------- State ----------
    const state = {
      surfaceElev: 20,
      coverStart: 4,
      slopePct: 0.2,
      pipeOD_in: 12,
      startSta: 0,
      endSta: parseStation('50+00'), // interpreted as 5000 ft if using 100-ft stationing granularity
      utilities: [
        { id:'U-1', owner:'', type:'Storm Drain', size_in:6, depth_ft:2, station:'5+00' },
        { id:'U-2', owner:'', type:'Sewer',       size_in:24, depth_ft:6, station:'25+00' }
      ]
    };

    // ---------- DOM refs ----------
    const svg = document.getElementById('svg');
    const tbody = document.getElementById('tbody');
    const surfaceElevI = document.getElementById('surfaceElev');
    const coverStartI = document.getElementById('coverStart');
    const slopePctI = document.getElementById('slopePct');
    const pipeODI = document.getElementById('pipeOD');
    const projectLenI = document.getElementById('projectLen');

    // Legend
    const lgSurf = document.getElementById('lgSurf');
    const lgOD = document.getElementById('lgOD');
    const staStart = document.getElementById('staStart');
    const staEnd = document.getElementById('staEnd');

    // Controls
    document.getElementById('addRow').addEventListener('click',()=>{
      state.utilities.push({id:`U-${state.utilities.length+1}`, owner:'', type:'Other', size_in:4, depth_ft:3, station:'10+00'});
      renderTable(); draw();
    });
    document.getElementById('deleteSelected').addEventListener('click',()=>{
      const checks = Array.from(document.querySelectorAll('input.rowSel:checked')).map(c=>parseInt(c.dataset.idx,10)).sort((a,b)=>b-a);
      for(const idx of checks){ state.utilities.splice(idx,1); }
      renderTable(); draw();
    });
    document.getElementById('exportJSON').addEventListener('click',()=>{
      const blob = new Blob([JSON.stringify(state,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'),{href:url,download:'utility_profile_config.json'});
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });
    document.getElementById('importJSON').addEventListener('change',e=>{
      const f = e.target.files?.[0]; if(!f) return;
      const r = new FileReader(); r.onload=()=>{ try{ Object.assign(state, JSON.parse(r.result)); }catch{} renderAll();}; r.readAsText(f);
    });
    document.getElementById('downloadSvg').addEventListener('click',()=>{
      const data = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([data],{type:'image/svg+xml'});
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'),{href:url,download:'profile.svg'});
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // Bind inputs
    for(const [el, key, parseFn] of [
      [surfaceElevI,'surfaceElev',parseFloat],
      [coverStartI,'coverStart',parseFloat],
      [slopePctI,'slopePct',parseFloat],
      [pipeODI,'pipeOD_in',parseFloat]
    ]){
      el.addEventListener('input',()=>{ state[key] = parseFn(el.value)||0; renderAll(); })
    }
    projectLenI.addEventListener('input',()=>{ state.endSta = parseStation(projectLenI.value); renderAll(); })

    // ---------- Table rendering ----------
    function renderTable(){
      tbody.innerHTML = '';
      state.utilities.forEach((u,idx)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><input class="rowSel" type="checkbox" data-idx="${idx}" /></td>
          <td><input value="${u.id}" data-k="id" data-idx="${idx}"/></td>
          <td><input value="${u.owner||''}" data-k="owner" data-idx="${idx}"/></td>
          <td>
            <input list="utyTypes" value="${u.type}" data-k="type" data-idx="${idx}"/>
            <datalist id="utyTypes">
              <option>Storm Drain</option>
              <option>Sewer</option>
              <option>Gas</option>
              <option>Electric</option>
              <option>Telecom</option>
              <option>Other</option>
            </datalist>
          </td>
          <td><input type="number" step="0.01" value="${u.size_in}" data-k="size_in" data-idx="${idx}"/></td>
          <td><input type="number" step="0.01" value="${u.depth_ft}" data-k="depth_ft" data-idx="${idx}"/></td>
          <td><input value="${u.station}" data-k="station" data-idx="${idx}"/></td>
        `;
        tbody.appendChild(tr);
      });
      tbody.querySelectorAll('input').forEach(inp=>{
        inp.addEventListener('input',()=>{
          const idx = parseInt(inp.dataset.idx,10);
          const key = inp.dataset.k;
          if(key==='size_in' || key==='depth_ft'){ state.utilities[idx][key] = parseFloat(inp.value)||0; }
          else { state.utilities[idx][key] = inp.value; }
          draw();
        })
      })
    }

    // ---------- Geometry / Drawing ----------
    function draw(){
      const W = 1100, H = 520;
      const margin = {l:70, r:30, t:30, b:60};
      const innerW = W - margin.l - margin.r;
      const innerH = H - margin.t - margin.b;
      const start = state.startSta, end = Math.max(start+100, state.endSta||5000);

      // Vertical extents: include some headroom below pipes
      const surf = state.surfaceElev;
      const od_ft = (state.pipeOD_in||0)/12;
      const cov0 = state.coverStart||0;
      const slope = (state.slopePct||0)/100; // ft/ft
      const elev0_center = surf - cov0 - od_ft/2; // @ station start
      const elevEnd_center = elev0_center - slope*(end-start);
      const minElev = Math.min(elev0_center - od_ft - 2, elevEnd_center - od_ft - 2);
      const maxElev = surf + 1.5;

      const xScale = ft => margin.l + (ft-start)/(end-start) * innerW;
      const yScale = ft => margin.t + (maxElev - ft)/(maxElev - minElev) * innerH;

      // Clear
      svg.innerHTML = '';

      // Gridlines & stationing every 10+00 (i.e., every 1000 ft)
      const grid = document.createElementNS('http://www.w3.org/2000/svg','g');
      grid.setAttribute('stroke','#e2e8f0'); grid.setAttribute('stroke-width','1');

      const staInterval = 1000; // feet between 10+00 ticks (assuming +00 is 100-ft stationing)
      for(let s = Math.ceil(start/staInterval)*staInterval; s <= end; s += staInterval){
        const x = xScale(s);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x); line.setAttribute('x2',x);
        line.setAttribute('y1',yScale(minElev)); line.setAttribute('y2',yScale(maxElev));
        grid.appendChild(line);

        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x', x);
        txt.setAttribute('y', H - 24);
        txt.setAttribute('text-anchor','middle');
        txt.setAttribute('class','mono');
        txt.setAttribute('fill','#334155');
        txt.setAttribute('font-size','12');
        txt.textContent = fmtStation(s);
        svg.appendChild(txt);
      }
      svg.appendChild(grid);

      // Axes
      const axis = document.createElementNS('http://www.w3.org/2000/svg','g');
      axis.setAttribute('stroke','#94a3b8'); axis.setAttribute('stroke-width','1.5');
      // X axis
      const xAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
      xAxis.setAttribute('x1', xScale(start)); xAxis.setAttribute('x2', xScale(end));
      xAxis.setAttribute('y1', H - margin.b + 4); xAxis.setAttribute('y2', H - margin.b + 4);
      axis.appendChild(xAxis);
      // Y labels (a few)
      [surf, elev0_center, elevEnd_center].forEach((e,i)=>{
        const y = yScale(e);
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x', 12); t.setAttribute('y', y+4); t.setAttribute('fill','#334155'); t.setAttribute('font-size','12'); t.textContent = `${e.toFixed(2)} ft`;
        svg.appendChild(t);
      })
      svg.appendChild(axis);

      // Surface line (flat at surf)
      const surfLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      surfLine.setAttribute('x1', xScale(start)); surfLine.setAttribute('x2', xScale(end));
      surfLine.setAttribute('y1', yScale(surf)); surfLine.setAttribute('y2', yScale(surf));
      surfLine.setAttribute('stroke', '#0ea5e9'); surfLine.setAttribute('stroke-width','2.5');
      svg.appendChild(surfLine);

      // Pipe centerline polyline (two points are enough for straight slope)
      const pipe = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = [
        `${xScale(start)},${yScale(elev0_center)}`,
        `${xScale(end)},${yScale(elevEnd_center)}`
      ].join(' ');
      pipe.setAttribute('points', pts);
      pipe.setAttribute('fill','none');
      pipe.setAttribute('stroke', 'var(--pipe)');
      pipe.setAttribute('stroke-width', (od_ft*(innerH/(maxElev-minElev))).toString());
      pipe.setAttribute('stroke-linecap','round');
      svg.appendChild(pipe);

      // Pipe callouts at start (cover & slope)
      const coverTopY = yScale(surf);
      const coverBottomY = yScale(elev0_center + od_ft/2);
      const coverX = xScale(start) + 10;
      const coverLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      coverLine.setAttribute('x1', coverX); coverLine.setAttribute('x2', coverX);
      coverLine.setAttribute('y1', coverTopY); coverLine.setAttribute('y2', coverBottomY);
      coverLine.setAttribute('stroke', '#94a3b8'); coverLine.setAttribute('stroke-dasharray','4,4');
      svg.appendChild(coverLine);
      const coverTxt = document.createElementNS('http://www.w3.org/2000/svg','text');
      coverTxt.setAttribute('x', coverX + 6); coverTxt.setAttribute('y', (coverTopY+coverBottomY)/2);
      coverTxt.setAttribute('fill','#334155'); coverTxt.setAttribute('font-size','12');
      coverTxt.textContent = `Cover @ 0+00 = ${cov0.toFixed(2)} ft`;
      svg.appendChild(coverTxt);

      // Utilities (crossings as circles). Compute clearance at exact station.
      state.utilities.forEach(u=>{
        const sft = parseStation(u.station);
        const x = xScale(sft);
        const d = (u.size_in||0)/12; // diameter in ft
        // Depth given to TOP of utility. Elev of top, then center.
        const topElev = surf - (u.depth_ft||0);
        const centerElev = topElev - d/2;

        // Draw utility as circle section (profile):
        const cy = yScale(centerElev);
        const r = Math.max(2, d*(innerH/(maxElev-minElev))/2);
        const color = u.type.toLowerCase().includes('storm') ? getComputedStyle(document.documentElement).getPropertyValue('--sd')
                     : u.type.toLowerCase().includes('sewer') ? getComputedStyle(document.documentElement).getPropertyValue('--sewer')
                     : '#6b7280';
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('cx', x); circ.setAttribute('cy', cy); circ.setAttribute('r', r);
        circ.setAttribute('fill', color.trim()); circ.setAttribute('fill-opacity','0.35');
        circ.setAttribute('stroke', color.trim()); circ.setAttribute('stroke-width','2');
        svg.appendChild(circ);

        // Clearance calculation at this station
        const pipeCenterHere = elev0_center - slope*(sft-start);
        const pipeTop = pipeCenterHere + od_ft/2;
        const pipeBot = pipeCenterHere - od_ft/2;
        const utilTop = centerElev + d/2;
        const utilBot = centerElev - d/2;
        let clearance, note;
        if(utilTop <= pipeBot){ // utility fully below pipe
          clearance = (pipeBot - utilTop);
          note = `Clearance (under): ${(clearance*12).toFixed(0)} in`;
        } else if(utilBot >= pipeTop){ // utility fully above pipe
          clearance = (utilBot - pipeTop);
          note = `Clearance (above): ${(clearance*12).toFixed(0)} in`;
        } else {
          clearance = 0; note = `Conflict (overlap)`;
        }

        // Leader + label
        const tx = Math.min(x + 90, xScale(end)-80);
        const ty = cy - 10;
        const leader = document.createElementNS('http://www.w3.org/2000/svg','polyline');
        leader.setAttribute('points', `${x},${cy} ${tx-8},${ty-8} ${tx},${ty}`);
        leader.setAttribute('fill','none'); leader.setAttribute('stroke','#475569'); leader.setAttribute('stroke-width','1.5');
        svg.appendChild(leader);

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x', tx); label.setAttribute('y', ty);
        label.setAttribute('fill','#111827'); label.setAttribute('font-size','12');
        label.innerHTML = `${u.type} (${u.size_in}\") @ ${fmtStation(sft)}\n${note}`;
        svg.appendChild(label);
      });

      // Legend live values
      lgSurf.textContent = surf.toFixed(2);
      lgOD.textContent = (state.pipeOD_in||0).toFixed(2);
      staStart.textContent = fmtStation(start);
      staEnd.textContent = fmtStation(end);
    }

    function renderAll(){
      // Sync inputs back (for imported JSON)
      surfaceElevI.value = state.surfaceElev;
      coverStartI.value = state.coverStart;
      slopePctI.value = state.slopePct;
      pipeODI.value = state.pipeOD_in;
      projectLenI.value = fmtStation(state.endSta);
      renderTable();
      draw();
    }

    // Initialize
    renderAll();
  </script>
</body>
</html>
